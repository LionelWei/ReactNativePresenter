<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>RN Share</title>

		<link rel="shortcut icon" href="img/favicon.png">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style type="text/css">
			.title {
				color: rgb(0, 164, 221);
			}
			.white {
				color: white;
			}
			.text {
				color: white;
			}
			.blue-text {
				color: rgb(0, 164, 221)
			}
			.clearfix:after {
				content: ".";
				display: block;
				height: 0;
				visibility: hidden;
				clear: both;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<!-- slide正文 -->
<section data-transition="concave">
	<p>移动跨平台开发</p>
	<p class="title fragment fade-down">
		REACT NATIVE
	</p>
</section>
<section data-markdown style="text-align: left">
	<script type="text/template">
		### 为什么用 React Native <!-- .element: style="color: rgb(0, 164, 221)" -->
		- 跨平台开发
			- 一次编写, 处处运行 <!-- .element: style="font-size: 0.8em; color: #888888" -->
			- 降低开发成本 <!-- .element: style="font-size: 0.8em; color: #888888" -->
		- 开发效率高
			- 画界面很灵活 <!-- .element: style="font-size: 0.8em; color: #888888" -->
			- 调试方便 <!-- .element: style="font-size: 0.8em; color: #888888" -->
		- 渲染速度快
			- Virtual DOM <!-- .element: style="font-size: 0.8em; color: #888888" -->
			- 原生渲染 <!-- .element: style="font-size: 0.8em; color: #888888" -->
		- 提升 Android/iOS 开发技能
	</script>
</section>
<section>
	<p class="title">演示</p>
</section>
<section data-markdown style="text-align: left" data-separator="---" data-separator-vertical="--" data-separator-notes="^Note:">
	<script type="text/template">
		### 跨平台四大流派
		- Web 流
		- 代码转换流
		- 渲染速度快
		- 虚拟机流


		<div class="fragment fade-down" style="font-size: 0.5em; text-decoration:underline; font-style:italic;">
			<br>
			<br>
			<a href="http://fex.baidu.com/blog/2015/05/cross-mobile/?f=http://blogread.cn/&from=timeline" target="_Blank">
				by 百度前端团队
			</a>
		</div>

		--
		### Web 流
		- Hybrid
		- 内嵌WebView
		- PhoneGap/Cordova
		<p class="fragment fade-up" style="color: rgb(0, 164, 221)">
		性能慢?
		</p>
		NOTE:
		Hybrid 技术，它基于 Web 相关技术来实现界面及功能.
		槽点: 性能慢 并不是DOM慢, 而是渲染慢: 1. 浏览器优化差 -> JS解析慢(V8之后又很大改善) 2. CSS过于灵活复杂 3. DOM暴露出来的接口有限, 难以优化
		--
		### 代码转换流
		- 将某种语言转成 Objective-C、Java 或 C#，然后使用不同平台下的官方工具来开发
		- Java 转 Objective-C
		- Objective-C 转 Java
		- Java 转 C#
		- ...
		<img class="fragment fade-up"
			style="position: absolute; right: 150px; bottom: 0px;"
			src="./img/mengbi1.png" width="150px" />
		NOTE:
		用Java写然后转成OC, 再在XCode上编译?...
		--
		### 编译流
		- 将某个语言编译为二进制文件，生成动态库或打包成 apk/ipa/xap 文件
		- C/C++
			- 使用C++实现非界面部分, 如 <img src="./img/wechat-logo.png" height="50px" style="position: relative; top: 10px; border: none; margin: 0; background-color: transparent;"/>[ <u>Mars</u>](https://github.com/Tencent/mars)
			- 使用 OpenGL 来绘制界面, 常见于游戏中
			- 基于C++的跨平台UI库, 如QT
		- Xamarin
			- C# 开发 Android/iOS
		- RoboVM
			- Java 转为 iOS
		NOTE:
		Android/iOS/WP都支持C++. 底层语言反而变成跨平台的重要技术. Mars是C++编写的业务性无关，平台性无关的基础组件。主要包括: 网络模块, 日志模块, 多线程基础工具等.
		Xamarin 可以使用 C# 来开发 Android 及 iOS 应用，它是从 Mono 发展而来的，目前看起来商业运作得不错，相关工具及文档都挺健全。
		RoboVM不是虚拟机, 而是将Java转化成iOS的字节码. OkHttp好像有基于RoboVM的实现
		--
		### 虚拟机流
		- Java VM
			- J2ME
		- Unity3D/Cocos2d-js
		- Adobe AIR
		- NativeScript
		- <img src="./img/react-native-logo.svg" height="60px" style="position: relative; top: 10px; border: none; margin: 0; background-color: transparent;"/><font style="color: rgb(0, 216, 255);"> React Native</font>
		- <img src="./img/weex-logo.png" height="60px" style="position: relative; top: 10px; border: none; margin: 0; background-color: transparent;"/><font style="color: rgb(0, 180, 255);"> Weex</font>
		NOTE:
		游戏引擎大多都能跨平台，为了提升开发效率，不少引擎还内嵌了对脚本支持
		不同平台下画UI组件, 这个十几年前的 SWT 就是这么做的。Facebook 的 iOS 团队中不少成员是来自 Apple 的，React Native 的官方视频中说它能做到 App 内实时更新，其实这是 Apple 明文禁止的，要做得低调。评论中有人提到 Apple 居然在 iOS 8.2 中改条款了，可以下载执行 JavaScript，而且 UIKit 的作者都觉得 React Native 很赞. 总之得到Apple相关资源的支持.
	</script>
</section>
<section data-transition="slides">
	<p>JavaScript性能</p>
	<img class="fragment fade-up" src="./img/js_performance.png" width="500px" />
	<p class="fragment fade-up">
		引入JIT即时编译后, 性能大幅提升
	</p>
</section>
<section data-markdown style="text-align: left">
	<script type="text/template">
	### 解决方案
	- 非界面/基础模块用C++
	- 界面用JSVM系: React Native / Weex
	</script>
</section>
<section>
	<section>
		<div class="title">
			<p class="white">命令式编程</p>
			<p style="color: transparent;">.........<span class="fragment fade-up" style="color: white"> => HOW</span></p>
			<p>声明式编程</p>
			<p style="color: transparent;">.........<span class="fragment fade-left title"> => WHAT</span></p>
		</div>
	</section>
	<section class="clearfix">
		<p class="blue-text" style="text-align: left; font-size: 0.8em">命令式</p>
		<pre style="font-size: 0.5em; margin: 0"><code>LinearLayout ll = new LinearLayout(this);
TextView tv = new TextView(this);
tv.setText("hello world");
ll.addView(tv, new LinearLayout.LayoutParams(
        LinearLayout.LayoutParams.WRAP_CONTENT,
        LinearLayout.LayoutParams.WRAP_CONTENT));
setContentView(ll);</code></pre>
		<p class="blue-text" style="text-align: left; font-size: 0.8em">声明式</p>
		<pre style="font-size: 0.5em; margin: 0"><code>&lt;LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    &lt;TextView&gt;
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="hello world!" /&gt;
&lt;/LinearLayout&gt;</code></pre>
		<div class="fragment fade-in">
		    <div class="fragment fade-out">
		    	<img src="./img/hello-world-screenshot1.png" alt="hello-world-screenshot1" 
				style="position: fixed; right: 150px; bottom: 50px; width: 350px; border: none;">
		    </div>
	    </div>
	</section>
	<section>
		<p>Hello World</p>
		<iframe width="800px" height="450px" name="rndemo" frameborder=0 src="http://dabbott.github.io/react-native-web-player/#code=import%20React%2C%20%7B%20Component%20%7D%20from%20'react'%3B%0Aimport%20%7B%20AppRegistry%2C%20Text%20%7D%20from%20'react-native'%3B%0A%0Aclass%20HelloWorldApp%20extends%20Component%20%7B%0A%20%20render()%20%7B%0A%20%20%20%20return%20(%0A%20%20%20%20%20%20%3CText%3E%0A%20%20%20%20%20%20%20%20hello%20world%0A%20%20%20%20%20%20%3C%2FText%3E%0A%20%20%20%20)%3B%0A%20%20%7D%0A%7D%0A%0AAppRegistry.registerComponent('HelloWorldApp'%2C%20()%20%3D%3E%20HelloWorldApp)%3B"></iframe>
	</section>
	<section>
		<p>声明式 Demo</p>
		<iframe width="800px" height="460px" name="rndemo" frameborder=0 src="http://dabbott.github.io/react-native-web-player/#code=import%20React%2C%20%7B%20Component%20%7D%20from%20'react'%3B%0Aimport%20%7B%20AppRegistry%2C%20Text%2C%20TouchableOpacity%20%7D%20from%20'react-native'%3B%0Aclass%20HelloWorldApp%20extends%20Component%20%7B%0A%20%20state%20%3D%20%7B%0A%20%20%20%20description%3A%20'hello%20world'%2C%0A%20%20%7D%0A%20%20render()%20%7B%0A%20%20%20%20return%20(%0A%20%20%20%20%20%20%3CTouchableOpacity%20onPress%3D%7Bthis.press%7D%3E%0A%20%20%20%20%20%20%20%20%3CText%3E%0A%20%20%20%20%20%20%20%20%20%20%7Bthis.state.description%7D%0A%20%20%20%20%20%20%20%20%3C%2FText%3E%0A%20%20%20%20%20%20%3C%2FTouchableOpacity%3E%0A%20%20%20%20)%3B%0A%20%20%7D%0A%20%20press%20%3D%20()%20%3D%3E%20%7B%0A%20%20%20%20this.setState(%7B%0A%20%20%20%20%20%20description%3A%20'%E4%BD%A0%E5%A5%BD%2C%20%E4%B8%96%E7%95%8C'%2C%0A%20%20%20%20%7D)%0A%20%20%7D%0A%7D%0AAppRegistry.registerComponent('HelloWorldApp'%2C%20()%20%3D%3E%20HelloWorldApp)%3B"></iframe>
		<p class="fragment fade-up" style="margin: 0 100px; font-size: 0.8em">
			界面随状态的变化而变化<span class="fragment fade-right title"> => Android DataBinding</span></p>
		<aside class="notes">
			由此可以联想到Android DataBinding, 所以我们知道数据绑定这种所谓MVVM的模式不是凭空出现的, 而是借鉴了其他平台的特点. 我觉得主要是网页, 如果我们主动去了解这些知识, 就能较好的把握方向, 不至于等到新技术出来一头雾水, 跟不上趟.
		</aside>
	</section>
	<section data-markdown style="text-align: left">
		<script type="text/template">
		### 遇到各种坑...
		- 动画卡顿
		- 反应迟钝
		- 数据如何存储
		- 事件无法传递
		- ...
		<div class="fragment fade-right title" style="position: absolute; right: 150px; bottom: 100px; padding: 10px; font-size: 0.8em; border: dashed 1px rgb(0, 164, 221)">
			<p>1) 只要必要时重新渲染</p>
			<p>2) 直接设置控件样式</p>
			<p>3) 引入Redux...</p>
		</div>
		</script>
	</section>
</section>
<section>
	<section>
		<p class="title">JS与Native交互原理简介</p>		
	</section>
	<section>
		<p>Android WebView</p>
		<p style="text-align: left">Java调JS</p>
		<pre style="font-size: 0.5em; margin: 0"><code>webview.loadUrl("javascript: alert('haha')");</code></pre>
		<p style="text-align: left">JS调Java</p>
		<pre style="font-size: 0.5em; margin: 0"><code>webview.addJavascriptInterface(new Object() {
    @JavascriptInterface
    void foo() {
        Log.e("Demo", "foo");
    }
}, "bridge");

webview.loadUrl("javascript: window.bridge.foo()");
// 链接跳转: shouldOverrideUrlLoading()
</code></pre>
	</section>
	<section>
		<img src="./img/rnbridge.svg" style="background-color: white">
	</section>
</section>
<section>
	<section>
		<p class="title">热更新</p>
		<aside class="notes">
			Web开发中, JS修改完逻辑直接在浏览器上刷新就能开到效果. 这是因为JS是一门动态语言, 不需要事先编译. 浏览器每次刷新都动态地从服务端加载JS文件. 当服务端没有更新时, 浏览器会从缓存当中去取JS文件. RN的动态更新时同样的思路, 所有JS代码会打包成一个jsbundle. 当需要更新时, 从远程服务器上下载这个文件, 并重新加载, 就可以完成动态更新而不需发版本.
			禁止不经提交版本而改变应用的行为或功能. -> 禁止热更新? -> 使用JSPatch/rollout相关应用被警告
		</aside>
	</section>
	<section>
		<p style="color: red">果爹发飙</p>
		<img class="fragment fade-up" src="./img/apple-warning.png">
	</section>
	<section data-markdown style="text-align: left">
		<script type="text/template">
		- 热更新很方便
		- RN最大的优势不是热更新, 而是其跨平台技术
		- 没有热更新, 照样可以上RN
		</script>
	</section>
</section>
<section data-markdown style="text-align: left">
	<script type="text/template">
		### 结论 <!-- .element: style="color: rgb(0, 164, 221)" -->
		- 技术栈要与时俱进
		- 不仅要有深度, 还要有广度
	</script>
</section>
<section>
	<p class="title">结束</p>
</section>
	</div>
</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
			// Reveal.configure({ slideNumber: true });
		</script>
<!-- 		<a class="fork-reveal" style="display: block;" href="https://github.com/hakimel/reveal.js"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://github-camo.global.ssl.fastly.net/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork reveal.js on GitHub"></a>
		<script>
			if( !navigator.userAgent.match( /(iphone|android)/gi ) && !!document.querySelector ) {
				document.querySelector( '.fork-reveal' ).style.display = 'block';
			}
		</script>
 -->
	</body>
</html>
