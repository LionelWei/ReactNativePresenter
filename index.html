<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>RN Share</title>

		<link rel="shortcut icon" href="img/favicon.png">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style type="text/css">
			.title {
				color: rgb(0, 164, 221);
			}
			.white {
				color: white;
			}
			.text {
				color: white;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<!-- slide正文 -->
<section data-transition="concave">
	<p>移动跨平台开发</p>
	<p class="title fragment fade-down">
		REACT NATIVE
	</p>
</section>
<section data-markdown style="text-align: left">
	<script type="text/template">
		#### 为什么用React Native <!-- .element: style="color: rgb(0, 164, 221)" -->
		- 跨平台开发
			- 一次编写, 处处运行 <!-- .element: style="font-size: 0.8em; color: #888888" -->
			- 降低开发成本 <!-- .element: style="font-size: 0.8em; color: #888888" -->
		- 开发效率高
			- 画界面很灵活 <!-- .element: style="font-size: 0.8em; color: #888888" -->
			- 调试方便 <!-- .element: style="font-size: 0.8em; color: #888888" -->
		- 渲染速度快
			- Virtual DOM <!-- .element: style="font-size: 0.8em; color: #888888" -->
			- 原生渲染 <!-- .element: style="font-size: 0.8em; color: #888888" -->
	</script>
</section>
<section>
	<p class="title">演示</p>
</section>
<section data-markdown style="text-align: left" data-separator="---" data-separator-vertical="--" data-separator-notes="^Note:">
	<script type="text/template">
		### 跨平台四大流派
		- Web 流
		- 代码转换流
		- 渲染速度快
		- 虚拟机流


		<div class="fragment fade-down" style="font-size: 0.5em; text-decoration:underline; font-style:italic;">
			<br>
			<br>
			<a href="http://fex.baidu.com/blog/2015/05/cross-mobile/?f=http://blogread.cn/&from=timeline" target="_Blank">
				by 百度前端团队
			</a>
		</div>

		--
		### Web 流
		- Hybrid
		- 内嵌WebView
		- PhoneGap/Cordova
		<p class="fragment fade-up" style="color: rgb(0, 164, 221)">
		性能慢?			
		</p>
		NOTE:
		Hybrid 技术，它基于 Web 相关技术来实现界面及功能. 
		槽点: 性能慢 并不是DOM慢, 而是渲染慢: 1. 浏览器优化差 -> JS解析慢(V8之后又很大改善) 2. CSS过于灵活复杂 3. DOM暴露出来的接口有限, 难以优化 
		--
		### 代码转换流
		- 将某种语言转成 Objective-C、Java 或 C#，然后使用不同平台下的官方工具来开发
		- Java 转 Objective-C
		- Objective-C 转 Java
		- Java 转 C#
		- ... 
		<img class="fragment fade-up"
			style="position: absolute; right: 150px; bottom: 0px;"
			src="./img/mengbi1.png" width="150px" />
		NOTE:
		用Java写然后转成OC, 再在XCode上编译?...
		--
		### 编译流
		- 将某个语言编译为二进制文件，生成动态库或打包成 apk/ipa/xap 文件
		- C/C++
			- 使用C++实现非界面部分, 如[<u>微信Mars</u>](https://github.com/Tencent/mars)
			- 使用 OpenGL 来绘制界面, 常见于游戏中
			- 基于C++的跨平台UI库, 如QT
		- Xamarin
			- C# 开发 Android/iOS
		- RoboVM
			- Java 转为 iOS
		NOTE:
		Android/iOS/WP都支持C++. 底层语言反而变成跨平台的重要技术. Mars是C++编写的业务性无关，平台性无关的基础组件。主要包括: 网络模块, 日志模块, 多线程基础工具等.
		Xamarin 可以使用 C# 来开发 Android 及 iOS 应用，它是从 Mono 发展而来的，目前看起来商业运作得不错，相关工具及文档都挺健全。
		RoboVM不是虚拟机, 而是将Java转化成iOS的字节码. OkHttp好像有基于RoboVM的实现
		--
		### 虚拟机流
		- Java VM
			- J2ME
		- Unity3D/Cocos2d-js
		- Adobe AIR
		- NativeScript
		- React Native
		- Weex
		...
		NOTE:
		游戏引擎大多都能跨平台，为了提升开发效率，不少引擎还内嵌了对脚本支持
		不同平台下画UI组件, 这个十几年前的 SWT 就是这么做的。Facebook 的 iOS 团队中不少成员是来自 Apple 的，React Native 的官方视频中说它能做到 App 内实时更新，其实这是 Apple 明文禁止的，要做得低调。评论中有人提到 Apple 居然在 iOS 8.2 中改条款了，可以下载执行 JavaScript，而且 UIKit 的作者都觉得 React Native 很赞. 总之得到Apple相关资源的支持.
	</script>
</section>
<section data-transition="slides">
	<p>JavaScript性能</p>
	<img class="fragment fade-up" src="./img/js_performance.png" width="500px" />
	<p class="fragment fade-up">
		JIT即时编译 对于GUI/交互式程序影响不大
	</p>	
</section>
<section data-markdown style="text-align: left">
	<script type="text/template">
	### 解决方案
	- 非界面/基础模块用C++
	- 界面用JSVM系: React Native / Weex
	</script>
</section>
<section>
	<section>
		<div class="title">
			<p>命令式编程</p>		
			<p class="white">vs</p>		
			<p>声明式编程</p>		
		</div>		
	</section>
	<section>
		<p>以LinearLayout+Button为例 JAVA代码 vs XML</p>
	</section>
	<section>
		引出RN的hello world
	</section>
	<section>
		属性&props共同触发界面的变化
	</section>
	<section>
		填坑之一: 画面卡顿 过于频繁的重绘页面 -> 属性变化导致Re-Render -> 只在某些情况下触发渲染 或 setNativeProps
	</section>
</section>
<section>
	JS与Native交互原理简介
</section>
<section>
	<section>
		热更新
		CodePush
		参照<React Native入门与实践>写一下
	</section>
	<section>
		<p>果爹发飙</p>
		<p>禁止不经提交版本而改变应用的行为或功能. -> 禁止热更新? -> 使用JSPatch/rollout相关应用被警告</p>
	</section>
	<section>
		<p>热更新很方便</p>
		<p>RN最大的优势不是热更新, 而是其跨平台技术</p>
		<p>没有热更新, 照样可以上RN</p>
	</section>
</section>
<section>
<p class="title">结论</p>
<p>技术栈要与时俱进</p>
<p>不仅要有深度, 还要有广度</p>
<p>来吧, 一起RN! +盖章特效</p>
</section>

	</div>
</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
			Reveal.configure({ slideNumber: true });
		</script>
	</body>
</html>
